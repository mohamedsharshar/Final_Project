# -*- coding: utf-8 -*-
"""OCR_Scan_vision.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HnxQ4ZT89OidwEik0H3wdSaL89aIIVM_
"""

import os
from pdf2image import convert_from_path

PDF_FOLDER = "/content/drive/MyDrive/Vison_Data"  # ØºÙŠØ±Ù‡ Ø¹Ù„Ù‰ Ø­Ø³Ø¨ Ù…ÙƒØ§Ù† Ù…Ù„ÙØ§ØªÙƒ
OUTPUT_FOLDER = "/content/drive/MyDrive/Vison_Data_pdf_images"    # Ù‡Ù†Ø§ Ø§Ù„ØµÙˆØ± Ù‡ØªØªØ­ÙØ¸
import os
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

from pdf2image import convert_from_path

for pdf_file in os.listdir(PDF_FOLDER):
    if pdf_file.lower().endswith(".pdf"):
        pdf_path = os.path.join(PDF_FOLDER, pdf_file)

        pdf_name = os.path.splitext(pdf_file)[0]
        pdf_output_dir = os.path.join(OUTPUT_FOLDER, pdf_name)
        os.makedirs(pdf_output_dir, exist_ok=True)

        print(f"ğŸ“„ Processing: {pdf_file}")

        images = convert_from_path(pdf_path, dpi=300)

        for i, img in enumerate(images):
            img_path = os.path.join(pdf_output_dir, f"page_{i+1}.png")
            img.save(img_path, "PNG")

        print(f"âœ… Saved {len(images)} pages\n")

import os
import cv2
import numpy as np
from paddlex import create_model

# ÙÙˆÙ„Ø¯Ø± Ø§Ù„ØµÙˆØ± Ø§Ù„Ù†Ø§ØªØ¬Ø© Ù…Ù† Ø§Ù„Ù€ PDF
OUTPUT_FOLDER = "/content/drive/MyDrive/Vison_Data_pdf_images"  # ØºÙŠØ±Ù‡ Ø­Ø³Ø¨ Ù…ÙƒØ§Ù†Ùƒ

# ÙÙˆÙ„Ø¯Ø± Ù„Ø­ÙØ¸ Ø§Ù„ØµÙˆØ± Ø¨Ø¹Ø¯ Ø±Ø³Ù… Ø§Ù„Ù€ boxes
DRAW_FOLDER = "/content/drive/MyDrive/Vison_Data_pdf_images_boxes"
os.makedirs(DRAW_FOLDER, exist_ok=True)

# Initialize detector once for efficiency
detector = create_model("PP-OCRv5_server_det")

def detect_and_draw(image_path, output_path):
    # Load image
    img = cv2.imread(image_path)
    if img is None:
        print(f"Error: Could not load image from {image_path}")
        return

    # Predict using the pre-initialized detector
    results = detector.predict(image_path)

    # Draw bounding boxes
    for result in results:
        boxes = result["dt_polys"]
        for box in boxes:
            # Convert float coordinates to integers for cv2.polylines
            int_box = np.array(box, dtype=np.int32)
            # Draw polygon on the image (BGR format, so (0,0,255) is red)
            cv2.polylines(img, [int_box], isClosed=True, color=(0, 0, 255), thickness=2)

    # Save the image with drawn boxes
    cv2.imwrite(output_path, img)
    print(f"  âœ“ Saved image with boxes to {output_path}")


# Loop Ø¹Ù„Ù‰ ÙƒÙ„ PDF folder
for pdf_name in os.listdir(OUTPUT_FOLDER):
    pdf_folder = os.path.join(OUTPUT_FOLDER, pdf_name)
    if os.path.isdir(pdf_folder):
        print(f"Processing PDF: {pdf_name}")

        # Loop Ø¹Ù„Ù‰ ÙƒÙ„ ØµÙØ­Ø©
        for img_file in os.listdir(pdf_folder):
            if img_file.lower().endswith((".png", ".jpg", ".jpeg")):
                img_path = os.path.join(pdf_folder, img_file)

                # ÙÙˆÙ„Ø¯Ø± Ø§Ù„Ø­ÙØ¸ Ù„ÙƒÙ„ PDF
                save_folder = os.path.join(DRAW_FOLDER, pdf_name)
                os.makedirs(save_folder, exist_ok=True)
                save_path = os.path.join(save_folder, img_file)

                # Call detect_and_draw
                detect_and_draw(img_path, save_path)

import os
OUTPUT_FOLDER = "/content/drive/MyDrive/Vison_Data_pdf_images"  # Ø§Ù„ØµÙˆØ± Ø§Ù„Ù†Ø§ØªØ¬Ø© Ù…Ù† PDF
ROIS_FILE_FOLDER = "/content/drive/MyDrive/Vison_Data_pdf_rois"
os.makedirs(ROIS_FILE_FOLDER, exist_ok=True)

for pdf_name in os.listdir(OUTPUT_FOLDER):
    pdf_folder = os.path.join(OUTPUT_FOLDER, pdf_name)
    if os.path.isdir(pdf_folder):
        print(f"Processing PDF: {pdf_name}")

        all_rois = []
        all_bboxes = []

        for img_file in os.listdir(pdf_folder):
            if img_file.lower().endswith((".png", ".jpg", ".jpeg")):
                img_path = os.path.join(pdf_folder, img_file)
                print(f"  ğŸ–¼ Processing image: {img_file}")

                # Load image
                import cv2
                import numpy as np
                from paddlex import create_model
                detector = create_model("PP-OCRv5_server_det")
                img = cv2.imread(img_path)
                h_img, w_img = img.shape[:2]

                # Predict
                results = detector.predict(img_path)

                for result in results:
                    boxes = result["dt_polys"]
                    for box in boxes:
                        pts = np.array(box, dtype=np.int32)
                        x, y, w, h = cv2.boundingRect(pts)
                        x1 = max(x, 0)
                        y1 = max(y, 0)
                        x2 = min(x + w, w_img)
                        y2 = min(y + h, h_img)
                        roi = img[y1:y2, x1:x2]
                        all_rois.append(roi)
                        all_bboxes.append((x1, y1, x2, y2))

        # Save single file per PDF
        output_file = os.path.join(ROIS_FILE_FOLDER, f"{pdf_name}_rois.npz")
        np.savez(output_file, images=np.array(all_rois, dtype=object), bboxes=np.array(all_bboxes))
        print(f"âœ“ Saved {len(all_rois)} ROIs into {output_file}\n")

import os
import numpy as np

def crop_rois_to_single_file(dummy_output_image_name, output_npz_filename):
    """
    Combines all individual ROI .npz files from ROIS_FILE_FOLDER into a single .npz file.
    The dummy_output_image_name argument is ignored, as the primary goal is
    to consolidate ROI data into a single NPZ archive for subsequent steps.
    """
    combined_rois = []
    combined_bboxes = []

    # ROIS_FILE_FOLDER is defined in cell _Bc9nQuEwHz0 and needs to be accessible.
    # Using the global variable as it's already set in the notebook state.
    global ROIS_FILE_FOLDER

    if not os.path.exists(ROIS_FILE_FOLDER):
        print(f"Error: ROIS_FILE_FOLDER '{ROIS_FILE_FOLDER}' does not exist.")
        return

    for filename in os.listdir(ROIS_FILE_FOLDER):
        if filename.endswith("_rois.npz"):
            npz_path = os.path.join(ROIS_FILE_FOLDER, filename)
            try:
                data = np.load(npz_path, allow_pickle=True)
                if "images" in data and "bboxes" in data:
                    combined_rois.extend(data["images"])
                    combined_bboxes.extend(data["bboxes"])
                else:
                    print(f"Warning: {npz_path} does not contain 'images' or 'bboxes' keys.")
            except Exception as e:
                print(f"Error loading {npz_path}: {e}")

    if combined_rois:
        # Save the combined data to the specified output_npz_filename in the current working directory
        np.savez(output_npz_filename, images=np.array(combined_rois, dtype=object), bboxes=np.array(combined_bboxes))
        print(f"âœ“ Successfully combined {len(combined_rois)} ROIs into {output_npz_filename}")
    else:
        print("No ROIs found to combine.")

# Call the function. Assuming 'output.jpg' is a placeholder or irrelevant for this specific consolidation task.
# The 'all_rois.npz' is the target file for the combined ROIs.
crop_rois_to_single_file("output.jpg", "all_rois.npz")

rois_file = "all_rois.npz"   # ØºÙŠØ± Ø§Ù„Ø§Ø³Ù… Ù„Ùˆ Ù…Ø®ØªÙ„Ù

data = np.load(rois_file, allow_pickle=True)

roi_images = data["images"]
roi_bboxes = data["bboxes"]

print(f"âœ“ Loaded {len(roi_images)} ROIs")

from paddlex import create_model

recognizer = create_model("arabic_PP-OCRv5_mobile_rec")

ocr_results = []

for i, roi in enumerate(roi_images):

    # Skip invalid crops
    if roi is None or roi.size == 0:
        continue

    # OCR Recognition (NO detection)
    rec_generator = recognizer.predict(roi)

    text = ""
    score = 0.0

    try:
        # Get the first (and likely only) result from the generator
        rec = next(rec_generator)
        text = rec["rec_text"]
        score = rec["rec_score"]
    except StopIteration:
        # No recognition result found for this ROI
        pass

    ocr_results.append({
        "box_id": i + 1,
        "text": text,
        "confidence": score,
        "bbox": roi_bboxes[i]
    })

print("===== OCR RESULTS =====\n")

for r in ocr_results:
    print(f"Box #{r['box_id']}")
    print(f"Text: {r['text']}")
    print(f"Confidence: {r['confidence']:.2%}")
    print(f"BBox: {r['bbox']}")
    print("-" * 50)

import json
import numpy as np

# Convert numpy arrays in ocr_results to lists for JSON serialization
serializable_ocr_results = []
for r in ocr_results:
    serializable_r = r.copy()
    if isinstance(serializable_r['bbox'], np.ndarray):
        serializable_r['bbox'] = serializable_r['bbox'].tolist()
    serializable_ocr_results.append(serializable_r)

with open("ocr_results.json", "w", encoding="utf-8") as f:
    json.dump(serializable_ocr_results, f, ensure_ascii=False, indent=2)

print("âœ“ Saved OCR output to ocr_results.json")

